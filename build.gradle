plugins {
    id 'java'
    id 'war'
    id 'org.flywaydb.flyway' version '9.8.1'
}
def projectProps = new Properties()
projectProps.load(new FileInputStream(rootProject.file("build.properties")))


repositories {
    mavenCentral()
}

sourceCompatibility = projectProps.getProperty('sourceCompatibility')
targetCompatibility = projectProps.getProperty('targetCompatibility')

tasks.withType(JavaCompile).configureEach {
    options.encoding = 'UTF-8'
}

dependencies {
    compileOnly('jakarta.json:jakarta.json-api:2.1.1')
    compileOnly('jakarta.enterprise:jakarta.enterprise.cdi-api:4.0.1')
    compileOnly('jakarta.validation:jakarta.validation-api:3.0.0')
    compileOnly('jakarta.ejb:jakarta.ejb-api:4.0.0')
    compileOnly('jakarta.faces:jakarta.faces-api:4.0.1')
    compileOnly('jakarta.servlet:jakarta.servlet-api:5.0.0')
    implementation 'org.projectlombok:lombok:1.18.28'
    implementation('org.hibernate:hibernate-core:6.0.2.Final')
    implementation('org.postgresql:postgresql:42.2.27')
    implementation('org.glassfish.jaxb:jaxb-runtime:3.0.2')
    implementation('org.primefaces:primefaces:13.0.0:jakarta')
    implementation('com.google.code.gson:gson:2.10.1')
    implementation 'org.apache.commons:commons-text:1.9'


//    testImplementation("org.junit.jupiter:junit-jupiter-api:${junitVersion}")
//    testRuntimeOnly("org.junit.jupiter:junit-jupiter-engine:${junitVersion}")
}

test {
    useJUnitPlatform()
}

flyway {
    locations = [projectProps.getProperty('flywayLocations')]
    url = projectProps.getProperty('dbUrl')
    user = projectProps.getProperty('dbUser')
    password = projectProps.getProperty('dbPassword')
    schemas = [projectProps.getProperty('flywaySchemas')]
}
flywayMigrate.dependsOn(classes)

jar {
    manifest {
        attributes(
                'Main-Class': projectProps.getProperty('mainClass'),
                'Implementation-Version': projectProps.getProperty('projectVersion')
        )
    }
}
tasks.register('compile') {
    group = 'build'
    description = 'Compilation of the project source code'
    dependsOn 'compileJava'
}

tasks.register('build_task') {
    group = 'build'
    description = 'Building the project and packing it into an executable Jar archive'
    dependsOn 'compile'
    finalizedBy 'jar'
}

tasks.register('clean_task') {
    group = 'build'
    description = 'Deleting all temporary files and compiled classes'
    dependsOn 'cleanJava'
    doLast {
        delete fileTree(dir: 'build', exclude: 'libs/')
    }
}

tasks.register('cleanJava', Delete) {
    description = 'Delete compiled Java classes'
    delete 'build/classes/java/main'
}

tasks.register('test_task') {
    group = 'verification'
    description = 'Launching JUnit tests of the project'
    dependsOn 'build_task'
    finalizedBy 'test'
}


tasks.register('javadoc_task', Javadoc) {
    group = 'documentation'
    description = 'Generate javadoc'
    dependsOn 'compile'

    source = sourceSets.main.allJava
    destinationDir = file("${buildDir}/javadoc")
    classpath = sourceSets.main.compileClasspath

    options {
        encoding = 'UTF-8'
        charSet = 'UTF-8'
        links("https://docs.oracle.com/javase/8/docs/api/")
        addStringOption('Xdoclint:none', '-quiet')
    }
}

import java.security.MessageDigest

tasks.register('md5sha1') {
    group = 'build'
    description = 'Calculating MD5 and SHA-1 checksums'
    dependsOn 'jar'
    doLast {
        def jarFile = file("build/libs/${project.name}.jar")
        if (!jarFile.exists()) {
            throw new FileNotFoundException("JAR file not found: ${jarFile.absolutePath}")
        }

        def md5 = MessageDigest.getInstance("MD5")
        def sha1 = MessageDigest.getInstance("SHA-1")

        jarFile.withInputStream { input ->
            byte[] buffer = new byte[8192]
            int bytesRead
            while ((bytesRead = input.read(buffer)) != -1) {
                md5.update(buffer, 0, bytesRead)
                sha1.update(buffer, 0, bytesRead)
            }
        }

        def md5Hex = md5.digest().encodeHex().toString()
        def sha1Hex = sha1.digest().encodeHex().toString()

        def manifestFile = file("${buildDir}/tmp/jar/MANIFEST.MF")
        manifestFile.parentFile.mkdirs()
        manifestFile.withWriterAppend { writer ->
            writer.println("MD5-Digest: ${md5Hex}")
            writer.println("SHA1-Digest: ${sha1Hex}")
        }
    }
}

tasks.register('doc') {
    group = 'documentation'
    description = 'Creating documentation, including Javadoc, and adding checksums to the manifest'
    dependsOn 'javadoc_task', 'md5sha1'
}

tasks.register('team') {
    group = 'build'
    description = 'Getting the 3 previous revisions from git, building them and packing them into a zip archive'

    doLast {
        def projectDir = project.projectDir.absolutePath
        def scriptDir = projectDir

        def command = ['groovy', "${scriptDir}/teamBuilder.groovy", projectDir, project.buildDir]
        def process = command.execute()
        process.waitFor()

        if (process.exitValue() != 0) {
            throw new GradleException("Failed to execute teamBuilder.groovy")
        }
    }
}


tasks.register('diff') {
    group = 'version control'
    description = 'Checks the status of the working copy and commits changes to the git repository if classes specified in the parameters file are modified'

    doLast {
        def projectDir = project.projectDir.absolutePath

        def paramsFile = new File(projectDir, "build.properties")
        def paramsProps = new Properties()
        paramsProps.load(new FileInputStream(paramsFile))

        def classesToMonitor = paramsProps.getProperty('classesToMonitor')

        if (classesToMonitor == null || classesToMonitor.isEmpty()) {
            println "No classes specified to monitor changes. Skipping diff task."
            return
        }

        def gitStatus = ['git', 'status', '--porcelain']
        def gitProcess = gitStatus.execute(null, new File(projectDir))
        gitProcess.waitFor()
        def gitOutput = gitProcess.text.trim()

        println "Git status output: \n${gitOutput}"

        if (gitOutput) {
            def modifiedFiles = gitOutput.split('\n').findAll { it.startsWith(' M') || it.startsWith('A') }.collect {
                it.substring(3).trim()
            }

            println "Modified files according to git status:"
            modifiedFiles.each { file ->
                println " - ${file}"
            }

            def changesDetected = false

            modifiedFiles.each { modifiedFile ->
                println "Modified file: ${modifiedFile}"
                if (modifiedFile.endsWith('.java')) {
                    changesDetected = true
                    def commitMessage = "Changes detected in ${modifiedFile}."
                    println "Committing changes: ${commitMessage}"
                    def gitCommit = ['git', 'commit', '-am', commitMessage]
                    def commitProcess = gitCommit.execute(null, new File(projectDir))
                    commitProcess.waitFor()

                    if (commitProcess.exitValue() != 0) {
                        throw new GradleException("Failed to commit changes.")
                    }

                    println "Changes committed: ${commitMessage}"
                }
            }

            if (!changesDetected) {
                println "No changes detected in specified classes."
            }
        } else {
            println "No changes detected."
        }
    }
}




import javax.xml.XMLConstants
import javax.xml.transform.stream.StreamSource
import javax.xml.validation.SchemaFactory

tasks.register('xml') {
    group = 'verification'
    description = 'Validate all XML files in the project'

    doLast {
        def projectDir = project.projectDir
        def xmlFiles = fileTree(projectDir).matching {
            include '**/*.xml'
        }

        if (xmlFiles.isEmpty()) {
            println "No XML files found in the project."
            return
        }

        xmlFiles.each { xmlFile ->
            try {
                SchemaFactory schemaFactory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);

                schemaFactory.newSchema().newValidator().validate(new StreamSource(xmlFile))
                println "Validation passed for file: ${xmlFile.path}"
            } catch (Exception e) {
                println "Validation failed for file: ${xmlFile.path}"
                println "Error message: ${e.message}"
            }
        }
    }
}


tasks.register('native2ascii') {
    group = 'localization'
    description = 'Convert localization files to ASCII encoding'

    def sourceDir = file('src/main/resources/localization')
    def targetDir = file("$buildDir/native2ascii")

    inputs.dir(sourceDir)
    outputs.dir(targetDir)

    doLast {
        println 'Starting native2ascii conversion'

        println "Source directory: $sourceDir"
        println "Target directory: $targetDir"

        if (!sourceDir.exists()) {
            throw new FileNotFoundException("Source directory not found: $sourceDir")
        }

        if (!targetDir.exists()) {
            targetDir.mkdirs()
        }

        sourceDir.eachFileRecurse { file ->
            if (file.isFile() && file.name.endsWith('.properties')) {
                println "Processing file: $file"

                def relativePath = sourceDir.toPath().relativize(file.toPath()).toString()
                def targetFile = new File(targetDir, relativePath)
                targetFile.parentFile.mkdirs()

                def properties = new Properties()
                file.withReader('UTF-8') { reader ->
                    properties.load(reader)
                }
                targetFile.withWriter('ASCII') { writer ->
                    properties.store(writer, null)
                }

                println "File converted: ${file} -> ${targetFile}"
            } else {
                println "Skipping file: $file"
            }
        }

        println 'Finished native2ascii conversion'
    }
}


tasks.register('history') {
    group = 'version control'
    description = 'If the project fails to compile, loads the previous version from the git repository. The operation is repeated until the project compiles successfully, or the earliest revision from the repository is obtained. If such a revision is found, a file containing the result of the diff operation for all files changed in the revision following the last successful build is generated.'

    doLast {
        def projectDir = project.projectDir.absolutePath

        def buildPropsFile = new File(projectDir, "build.properties")
        def buildProps = new Properties()
        buildProps.load(new FileInputStream(buildPropsFile))

        def success = false
        def currentRevision = null
        def previousRevision = null

        def gitRevParse = ['git', 'rev-parse', 'HEAD']
        def revParseProcess = gitRevParse.execute(null, new File(projectDir))
        revParseProcess.waitFor()

        if (revParseProcess.exitValue() == 0) {
            currentRevision = revParseProcess.text.trim()
        }

        if (currentRevision == null) {
            println "Failed to retrieve current revision. Exiting history task."
            return
        }

        def compileProject = {
            println "Compiling project using revision ${currentRevision}..."
            def gitCheckout = ['git', 'checkout', currentRevision]
            def checkoutProcess = gitCheckout.execute(null, new File(projectDir))
            checkoutProcess.waitFor()

            def os = System.getProperty('os.name').toLowerCase()
            def gradleCommand = os.contains('windows') ? ['cmd', '/c', 'gradlew.bat', 'compileJava'] : ['./gradlew', 'compileJava']

            def compileProcess = gradleCommand.execute(null, new File(projectDir))
            compileProcess.waitFor()

            if (compileProcess.exitValue() == 0) {
                println "Build successful."
                success = true
            } else {
                println "Compilation failed: ${compileProcess.errorStream.text}"
                success = false
            }
        }

        while (!success && currentRevision != null) {
            compileProject()
            if (!success) {
                println "Build failed using revision ${currentRevision}."
                def gitLog = ['git', 'log', '--pretty=format:"%H"', '--reverse', currentRevision + '^..HEAD']
                def logProcess = gitLog.execute(null, new File(projectDir))
                logProcess.waitFor()

                def logOutput = logProcess.text.trim()

                if (logOutput) {
                    def revisions = logOutput.tokenize("\n")
                    if (revisions.size() > 1) {
                        previousRevision = revisions[1].replaceAll("\"", "")
                    }
                }

                if (previousRevision != null) {
                    println "Previous revision: ${previousRevision}"
                    currentRevision = previousRevision
                } else {
                    println "No previous revision found."
                    currentRevision = null
                }
            }
        }

        if (!success) {
            println "Unable to build using any revision. Generating diff file..."
            def diffFile = new File(projectDir, "build/diff.txt")

            def gitDiff = ['git', 'diff', '--name-status', currentRevision + '..HEAD']
            def diffProcess = gitDiff.execute(null, new File(projectDir))
            diffProcess.waitFor()

            def diffOutput = diffProcess.text.trim()

            if (diffOutput) {
                diffFile.write(diffOutput)
                println "Diff file generated: ${diffFile.absolutePath}"
            } else {
                println "No differences found between revisions."
            }
        }

        def gitCheckout = ['git', 'checkout', 'master']
        def checkoutProcess = gitCheckout.execute(null, new File(projectDir))
        checkoutProcess.waitFor()
        if (checkoutProcess.exitValue() == 0) {
            println "Checked out to original revision."
        } else {
            println "Failed to checkout to original revision: ${checkoutProcess.errorStream.text}"
        }
    }
}
